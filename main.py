# -*- coding: utf-8 -*-
"""Main.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fRZUEgZELB4gfGNK-1zFkZk4FP0qxFQO
"""

pip install requests

pip install urlopen

pip install geopandas

import requests
import urlopen
import matplotlib.pyplot as plt
import pandas as pd
import plotly.graph_objects as go
from keras.models import Sequential
from keras.layers import Dense,Activation,Flatten
from sklearn.preprocessing import MinMaxScaler
import geopandas as gpd


page = requests.get("https://coronavirus.wilkinsonpc.com.co/")
pageedad = requests.get("https://coronavirus.wilkinsonpc.com.co/casos-por-edad.html")
pagegeneral =  requests.get("https://datosmacro.expansion.com/otros/coronavirus/colombia")

page.status_code
pageedad.status_code
pagegeneral.status_code

page.content

pageedad.content

pagegeneral.content

pip install beautifulsoup4

#importing the BeautifulSoup library
from bs4 import BeautifulSoup

#Instatiating the BeautifulSoup Class
soup = BeautifulSoup(page.content, 'lxml')
soupedad = BeautifulSoup(pageedad.content, 'lxml')
soupgen = BeautifulSoup(pagegeneral.content, 'lxml')
#Where soup is a variable containing the HTML of the webpage

#Lets formatt it nicely, using the prettify method as contrasts as cell 3
print(soup.prettify())

#Lets formatt it nicely, using the prettify method as contrasts as cell 3
print(soupedad.prettify())

#Lets formatt it nicely, using the prettify method as contrasts as cell 3
print(soupgen.prettify())

# Search for the table and extracting it
tableciudad = soup.find('table', attrs={'class': 'tabla1'})
tabledep = soup.find('table', attrs={'class': 'tabla2'})
tableedad = soupedad.find('table', attrs={'class': 'tabla1'})
tablegen = soupgen.find('table', attrs={'id': 'tb'})

"""data recolectada

"""

tableciudad

tabledep

tableedad

tablegen

"""Se guarda la data recolectada en arreglos"""

dataciudad = []
table_rowsciudad = tableciudad.find_all('tr')
for tr in table_rowsciudad:
    td = tr.find_all('td')
    row = [tr.text for tr in td]
    dataciudad.append(row)

datadepartamento = []
table_rowsdep = tabledep.find_all('tr')
for tr in table_rowsdep:
    td = tr.find_all('td')
    row = [tr.text for tr in td]
    datadepartamento.append(row)

dataedad = []
table_rowsedad = tableedad.find_all('tr')
for tr in table_rowsedad:
    td = tr.find_all('td')
    row = [tr.text for tr in td]
    dataedad.append(row)

datageneral = []
table_rowsgen = tablegen.find_all('tr')
for tr in table_rowsgen:
    td = tr.find_all('td')
    row = [tr.text for tr in td]
    datageneral.append(row)

datadepartamento

dtgen = pd.DataFrame(datageneral, columns=["Fecha" ,"Incremento Muertos", "Muertos", "Muertos / millón", "Incremento Confirmados", "Confirmados", "Confirmados / 100.000 - 14 días"])
dtedad = pd.DataFrame(dataedad, columns=["Edad","Mujeres","Hombres","Recuperados","Fallecidos","Críticos","Hospital","Casa","Total"])
dtciudad = pd.DataFrame(dataciudad, columns=["Ciudad","Casos"])
dtdepartamento = pd.DataFrame(datadepartamento, columns=["Departamento","Casos"])

dtgen

dtciudad

dciudad = dtciudad.drop([0],axis=0)

import plotly.express as px

fig = px.scatter(dtciudad, x='Casos', y='Ciudad')
fig.show()

dtedad

dedad = dtedad.drop([0, 1, 14],axis=0)

dedad

dedad.Fallecidos=pd.to_numeric(dedad.Fallecidos)
dedad.Mujeres=pd.to_numeric(dedad.Mujeres)
dedad.Hombres=pd.to_numeric(dedad.Hombres)
dedad.Recuperados=pd.to_numeric(dedad.Recuperados)
dedad.Críticos=pd.to_numeric(dedad.Críticos)
dedad.Hospital=pd.to_numeric(dedad.Hospital)

##dtciudad.plot(x="Ciudad", y="Casos")
##plt.plot(dedad["Edad"],dedad["Mujeres"])
##plt.show()

fig = go.Figure(data=[
    go.Bar(name='Mujeres', x=dedad["Edad"],y=dedad["Mujeres"]),
    go.Bar(name='Hombres', x=dedad["Edad"],y=dedad["Hombres"])
])
# Change the bar mode
fig.update_layout(barmode='group')
fig.show()

fig = go.Figure(data=[
    go.Bar(name='Hospital', x=dedad["Edad"],y=dedad["Hospital"]),
    go.Bar(name='Casa', x=dedad["Edad"],y=dedad["Casa"])
])
# Change the bar mode
fig.update_layout(barmode='group')
fig.show()

import plotly.express as px

fig = px.pie(dedad, values='Recuperados', names='Edad')
fig.show()

import plotly.express as px

fig = px.pie(dedad, values='Fallecidos', names='Edad', hole=.3)
fig.show()

dtdepartamento

ddepartamento = dtdepartamento.drop([0],axis=0)

fig = go.Figure(data=[
    go.Bar(name='Departamento', x=ddepartamento["Departamento"],y=ddepartamento["Casos"])
])
# Change the bar mode
fig.update_layout(barmode='group')
fig.show()

pip install dask[dataframe]

# to suppress future warnings
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

import dask.dataframe as dd

dedad.describe().T

import scipy.stats as stats
import matplotlib.pyplot as plt
import seaborn as sms
# Separar dependiendo un porcentaje, grupo de entrenamiento y grupo de prueba
from sklearn.model_selection import train_test_split
# Modelo de regresión lineal
from sklearn.linear_model import LinearRegression
# Métricas de evaluacion
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import math

matrixCorrelacion= dedad.corr()

matrixCorrelacion

sms.heatmap(dedad.corr(), cmap="Blues" , fmt='g')

# En función del valor de correlación (umbral), se presenta una relación entre las variables
# Hacer una función que me selecciones las features según un "umbral"
def relacionFeatures(corrMatrix, umbral):
  feature = []
  valores = []

  for i, index in enumerate(corrMatrix.index):
    if abs(corrMatrix[index]) > umbral:
      feature.append(index)
      valores.append(corrMatrix[index])

  df = pd.DataFrame(data = valores, index = feature, columns=['Valor de Correlación'])
  return df

#Función que devuelva un dataframe con las métricas de rendimiento ['nombre features', 'valorCorrelacion', 'r2_score', 'MAE',  'MSE']

def Metricas(umbral):

  # Se seleccionan las  features según el umbral
  valorCorrelacion = relacionFeatures(matrixCorrelacion['Recuperados'], umbral)

  # Se obtiene y se envia al dataset el valor de la correlación
  dataCorrelacion = dedad[valorCorrelacion.index]
  y_predict,y_test = entrenamiento(dataCorrelacion)
  
  #Se evaluan los datos en el modelo
  puntuacion = r2_score(y_test, y_predict)
  MAE= mean_absolute_error(y_test, y_predict)
  MSE = mean_squared_error(y_test, y_predict)
  
  #Se agregan las metricas de rendimiento
  dataCorrelacion['r2_score']=puntuacion
  dataCorrelacion['Mean Absolute Error']=MAE
  dataCorrelacion['Mean Squared Error']=MSE
  return dataCorrelacion.head()

#Función que entrene el modelo y devuelva el y_predict directamente
def entrenamiento(dataCorrelacion):
  X = dataCorrelacion.drop('Recuperados', axis=1)
  y = dataCorrelacion['Recuperados']

  #Dividir en conjunto de train y test
  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=0)

  # Selección del Modelo Lineal
  modelo = LinearRegression()

  # Entrenar el modelo
  
  modelo.fit(X_train, y_train)

  # Variables de predicción
  y_predict_train = modelo.predict(X_train)
  y_predict = modelo.predict(X_test)
  return y_predict,y_test

#EL UMBRAL PARA ESTE SERA DE 0.7
Metricas(0.7)

# El modelo de regresión lineal
from sklearn.linear_model import LinearRegression
from sklearn import datasets, linear_model

x = dedad['Hombres'].values.reshape(-1, 1)
y = dedad['Recuperados'].values.reshape(-1, 1)
regresionLinear = linear_model.LinearRegression()
regresionLinear.fit(x,y)
y_predit=regresionLinear.predict(x)

print("Mean Squared Error Hombres:",mean_squared_error(y, y_predit))

## la idea es seleccionar las variables segun el umbral de correlacion
## se desea identificar la multicolinealidad
## variable target es 'Profit'
## umbral 0.7

umbral = 0.7
valorcorrelacion = relacionFeatures(matrixCorrelacion['Recuperados'],umbral)
valorcorrelacion

## se hace un analisis estadistico
## Importar las librerias necesarias

import statsmodels.api as sample_data
from statsmodels.stats.outliers_influence import variance_inflation_factor

# Seleccionar las features según el umbral
valorCorrelacion = relacionFeatures(matrixCorrelacion['Recuperados'], 0.7)
  
# Se transforma el valor de correlacion
dataCorrelacion = dedad[valorCorrelacion.index]

# Se ajusta a un modelo de Regresión Lineal
X = dataCorrelacion.drop('Recuperados', axis=1)
y = dataCorrelacion['Recuperados']

pd.DataFrame([[var, variance_inflation_factor(X.values,X.columns.get_loc(var))] for var in X.columns],
             index=range(X.shape[1]), columns=['Variable','VIF'])

import numpy as np

def plot_learning_curve(estimator, title, X, y, axes=None, ylim=None, cv=None,
                        n_jobs=None, train_sizes=np.linspace(.1, 1.0, 5)):
    plt.figure()
    plt.title(title)

    train_sizes, train_scores, test_scores = learning_curve(estimator, X, y,
                                                            cv=cv, n_jobs=n_jobs,
                                                            train_sizes=train_sizes)
    
    train_scores_mean = np.mean(train_scores, axis=1)
    train_scores_std = np.std(train_scores, axis=1)
    test_scores_mean = np.mean(test_scores, axis=1)
    test_scores_std = np.std(test_scores, axis=1)
    
    plt.grid()

    # Plot learning curve
    
    plt.fill_between(train_sizes, train_scores_mean - train_scores_std,
                         train_scores_mean + train_scores_std, alpha=0.1,
                         color="r")
    plt.fill_between(train_sizes, test_scores_mean - test_scores_std,
                         test_scores_mean + test_scores_std, alpha=0.1,
                         color="g")
    plt.plot(train_sizes, train_scores_mean, 'o-', color="r",
                 label="Training score")
    plt.plot(train_sizes, test_scores_mean, 'o-', color="g",
                 label="Cross-validation score")
    plt.legend(loc="best")

    return plt

## Importar las librerias necesarias
from sklearn.model_selection import learning_curve, ShuffleSplit

# Seleccionar las features según el umbral
valorCorrelacion = relacionFeatures(matrixCorrelacion['Recuperados'], 0.7)
  
# Se transforma el valor de correlacion
dataCorrelacion = dedad[valorCorrelacion.index]

# Se ajusta a un modelo de Regresión Lineal
X = dataCorrelacion.drop('Recuperados', axis=1)
y = dataCorrelacion['Recuperados']

title = 'Curvas de aprendizaje'+ str(X.columns.values)
cv = ShuffleSplit(n_splits=100, test_size = 0.25)
estimador = LinearRegression()
plot_learning_curve(estimador,title,X,y,cv,n_jobs=1)
plt.show()

import numpy as np
import matplotlib.pyplot as plt 
import pandas as pd  
import csv

url = "https://raw.githubusercontent.com/Jruedagutirrez/analisisdesenales/main/osbcovid19_Abril20.csv"
data = pd.read_csv(url, encoding = "ISO-8859-1")
data_copy=data.copy()

cantidad_contagiados=len(data)
print('cantidad de contagiados por COVID en Bogota:', cantidad_contagiados)

cantidad_contagiados_M=len(data[(data["Sexo"]=="M")])
print('cantidad de hombres contagiados por COVID:', cantidad_contagiados_M, '(',cantidad_contagiados_M*100/cantidad_contagiados, '%)')

cantidad_contagiados_F=len(data[(data["Sexo"]=="F")])
print('cantidad de mujeres contagiadas por COVID:', cantidad_contagiados_F, '(',cantidad_contagiados_F*100/cantidad_contagiados, '%)')

registro=len(data)
data.head(registro)

ax=data.hist('Edad', bins=np.int((max(data['Edad']) - min(data['Edad']) + 1)))
print('Casos contagio COVID-19 en Bogotá por edad')

data_fallecidos=data[(data["Estado"]=="Fallecido")]
print('Cantidad de fallecidos por COVID-19 en Bogotá:', len(data_fallecidos))

url = "https://raw.githubusercontent.com/Jruedagutirrez/analisisdesenales/main/dataset_covid_localidades_bogota.csv"
dataloc = pd.read_csv(url, encoding = "ISO-8859-1" , sep=';', index_col=0)
dataloc.head()

dataloc

dataloc.Femenino=pd.to_numeric(dataloc.Femenino)
dataloc.Masculino=pd.to_numeric(dataloc.Masculino)

import plotly.express as px

fig = px.bar(dataloc, x="Femenino", y="Localidad", color='Femenino', orientation='h',
             hover_data=["Localidad", "Femenino"],
             height=400,
             title='Femenino / Localidad / Covid-19')
fig.show()

fig = px.bar(dataloc, x="Masculino", y="Localidad", color='Masculino', orientation='h',
             hover_data=["Localidad", "Masculino"],
             height=400,
             title='Masculino / Localidad / Covid-19')
fig.show()